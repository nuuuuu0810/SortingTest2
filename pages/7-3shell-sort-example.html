<section id="7-3shell-sort-example" class="content-page">
    <h2>シェルソートの仕組み（5個）</h2>
    <p>シェルソートの動作を、5つの要素で具体的に見てみましょう。</p>
    <p>配列: `[34, 8, 64, 51, 32]` (要素数 N=5)</p>
    <p>ギャップの系列として、ここでは `h = floor(N/2), floor(h/2), ..., 1` を使います。</p>
    <p>初期ギャップ: `h = floor(5/2) = 2`</p>
    <h3>ステップ 1: ギャップ `h = 2` でソート</h3>
    <p>配列: `[34, 8, 64, 51, 32]`</p>
    <p>以下の部分配列に挿入ソートを適用します:</p>
    <ul>
        <li><strong>グループ1 (インデックス 0, 2, 4): `[34, 64, 32]`</strong>
            <ul>
                <li>`64` を挿入 (対 `34`): `[34, 64, 32]` (変化なし)</li>
                <li>`32` を挿入 (対 `64`, `34`):
                    <ul>
                        <li>`32 < 64` → `64` をシフト (仮)</li>
                        <li>`32 < 34` → `34` をシフト (仮)</li>
                        <li>結果: `[32, 34, 64]` (このグループ内でのソート結果)</li>
                    </ul>
                </li>
                <li>配列に反映: `[32, 8, 34, 51, 64]` (元の配列の対応する位置が更新される)</li>
            </ul>
        </li>
        <li><strong>グループ2 (インデックス 1, 3): `[8, 51]`</strong>
            <ul>
                <li>`51` を挿入 (対 `8`): `[8, 51]` (変化なし)</li>
                <li>配列に反映: (上記の配列は既にこのグループの結果を織り込んでいるので、実質変化なし) `[32, 8, 34, 51, 64]`</li>
            </ul>
        </li>
    </ul>
    <p>ギャップ `h=2` でのソート後配列: `[32, 8, 34, 51, 64]`</p>
    <h3>ステップ 2: 次のギャップ `h = floor(2/2) = 1` でソート</h3>
    <p>配列: `[32, 8, 34, 51, 64]`</p>
    <p>ギャップ `h=1` は、通常の挿入ソートと同じです。配列全体に挿入ソートを適用します。</p>
    <ul>
        <li>`32` (最初の要素) は整列済みとみなす。</li>
        <li><strong>キー `8` (インデックス 1):</strong>
            <ul>
                <li>`8 < 32`。`32` を右にシフト。`8` を先頭に挿入。</li>
                <li>配列: `[8, 32, 34, 51, 64]`</li>
            </ul>
        </li>
        <li><strong>キー `34` (インデックス 2):</strong>
            <ul>
                <li>`34 > 32`。`34 > 8`。位置はそのまま。</li>
                <li>配列: `[8, 32, 34, 51, 64]`</li>
            </ul>
        </li>
        <li><strong>キー `51` (インデックス 3):</strong>
            <ul>
                <li>`51 > 34`。位置はそのまま。</li>
                <li>配列: `[8, 32, 34, 51, 64]`</li>
            </ul>
        </li>
        <li><strong>キー `64` (インデックス 4):</strong>
            <ul>
                <li>`64 > 51`。位置はそのまま。</li>
                <li>配列: `[8, 32, 34, 51, 64]`</li>
            </ul>
        </li>
    </ul>
    <p>ギャップ `h=1` でのソート後配列 (最終結果): `[8, 32, 34, 51, 64]`</p>
    <p>この例では、ギャップ2の段階で要素がある程度適切な位置に近づき、最後のギャップ1（挿入ソート）での処理が効率的に行われました。</p>
</section>