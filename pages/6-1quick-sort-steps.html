<section id="6-1quick-sort-steps" class="content-page">
    <h2>クイックソート ステップ</h2>
    <p>クイックソートの動作は、ピボットの選び方やパーティショニングの具体的な方法によって多少異なりますが、ここでは一般的なホーアのパーティション方式に近い考え方で説明します。</p>
    <p>仮に、以下のような配列 `[7, 2, 1, 6, 8, 5, 3, 4]` があるとします。</p>
    <h3>ステップ 1: 最初のパーティショニング</h3>
    <ol>
        <li>配列: `[7, 2, 1, 6, 8, 5, 3, 4]`</li>
        <li>ピボットを選びます。ここでは最初の要素 `7` をピボットとします。 (実際には、中央値やランダムな要素を選ぶ方が性能が安定します)</li>
        <li>配列をスキャンし、要素をピボット `7` と比較して分割します。
            <ul>
                <li>`7` より小さい要素を左側に、大きい要素を右側に集めます。</li>
                <li>左から `7` 以上の要素を探し (ここでは先頭の `7`)、右から `7` 以下の要素を探します (ここでは `4`)。これらを交換します。 `[4, 2, 1, 6, 8, 5, 3, 7]` (ポインタが交差するまで繰り返す)</li>
                <li>さらに進めると... (詳細なパーティションの動きは複雑なのでここでは結果を示します)</li>
            </ul>
        </li>
        <li>パーティショニングの結果の一例 (ピボットが特定の位置に移動するとは限らない): `[4, 2, 1, 6, 3, 5]` (ピボット `7` より小さい) | `7` (ピボット) | `[8]` (ピボット `7` より大きい)
            実際にはピボットを固定し、それ以外を左右に分けることが多いです。
            ここでは、ピボットを `4` (例として配列の最後の要素) として、より一般的な Lomuto partition scheme で考えます。
            配列: `[7, 2, 1, 6, 8, 5, 3, 4]` ピボット: `4`</li>
        <li>ピボット `4` より小さい要素を左に、大きい要素を右に集めます。
            <ul>
                <li>`i` を左端の前に、`j` を左端から右端の手前まで動かす。</li>
                <li>`array[j] <= pivot` なら `i` を進めて `array[i]` と `array[j]` を交換。</li>
            </ul>
            <pre><code class="language-text">[7, 2, 1, 6, 8, 5, 3, 4]  pivot = 4
 i
 j
-> 2 <= 4: swap(arr[i+1], arr[j]) -> [2, 7, 1, 6, 8, 5, 3, 4] i=0
   j
-> 1 <= 4: swap(arr[i+1], arr[j]) -> [2, 1, 7, 6, 8, 5, 3, 4] i=1
      j
-> 6 > 4
         j
-> 8 > 4
            j
-> 5 > 4
               j
-> 3 <= 4: swap(arr[i+1], arr[j]) -> [2, 1, 3, 6, 8, 5, 7, 4] i=2
                  j
最後に pivot と arr[i+1] を交換: swap(arr[i+1], arr[pivot_idx])
-> [2, 1, 3, 4, 8, 5, 7, 6]  (pivot=4が正しい位置に)</code></pre>
        </li>
        <li>分割結果:
            <ul>
                <li>左部分配列: `[2, 1, 3]` (ピボット `4` より小さい)</li>
                <li>ピボット: `4`</li>
                <li>右部分配列: `[8, 5, 7, 6]` (ピボット `4` より大きい)</li>
            </ul>
        </li>
    </ol>
    <h3>ステップ 2: 左部分配列 `[2, 1, 3]` を再帰的にソート</h3>
    <ol>
        <li>配列: `[2, 1, 3]`。ピボットを `3` (最後の要素) とします。</li>
        <li>パーティショニング:
            <pre><code class="language-text">[2, 1, 3] pivot = 3
 i
 j
-> 2 <= 3: swap(arr[i+1], arr[j]) -> [2, 1, 3] i=0
   j
-> 1 <= 3: swap(arr[i+1], arr[j]) -> [2, 1, 3] i=1 (間違い、正しくは[1,2,3])
   正しい処理:
   [2, 1, 3] pivot = 3
    i=-1
    j=0: arr[0]=2 <= 3. i=0. swap(arr[0],arr[0]) -> [2,1,3]
    j=1: arr[1]=1 <= 3. i=1. swap(arr[1],arr[1]) -> [2,1,3]
    最後に swap(arr[i+1], arr[pivot_idx]) -> swap(arr[2], arr[2]) -> [2,1,3]
    これはピボットが最大値の場合。
    もしピボットを最初の要素 `2` とすると: (Hoare partition の方が説明しやすいかも)
    ピボット: `2`. 左部分: `[1]`, 右部分: `[3]`</code></pre>
        </li>
        <li>左部分 `[1]` (ソート済み), 右部分 `[3]` (ソート済み)</li>
        <li>結果: `[1, 2, 3]`</li>
    </ol>
    <h3>ステップ 3: 右部分配列 `[8, 5, 7, 6]` を再帰的にソート</h3>
    <ol>
        <li>配列: `[8, 5, 7, 6]`。ピボットを `6` (最後の要素) とします。</li>
        <li>パーティショニング:
            <pre><code class="language-text">[8, 5, 7, 6] pivot = 6
 i=-1
 j=0: arr[0]=8 > 6
 j=1: arr[1]=5 <= 6. i=0. swap(arr[0],arr[1]) -> [5, 8, 7, 6]
 j=2: arr[2]=7 > 6
 (After loop) swap(arr[i+1], arr[pivot_index]): swap(arr[1], arr[3]) -> [5, 6, 7, 8]</code></pre>
        </li>
        <li>分割結果:
            <ul>
                <li>左部分配列: `[5]` (ピボット `6` より小さい) -> ソート済み</li>
                <li>ピボット: `6`</li>
                <li>右部分配列: `[7, 8]` (ピボット `6` より大きい)</li>
            </ul>
        </li>
        <li>右部分配列 `[7, 8]` を再帰的にソート:
            <ul>
                <li>ピボットを `8` とすると、左部分 `[7]`、右部分なし。結果 `[7, 8]`。</li>
            </ul>
        </li>
        <li>結果: `[5, 6, 7, 8]`</li>
    </ol>
    <h3>ステップ 4: 全体を結合</h3>
    <p>左部分 `[1, 2, 3]` + ピボット `4` + 右部分 `[5, 6, 7, 8]`</p>
    <p><strong>最終結果: `[1, 2, 3, 4, 5, 6, 7, 8]`</strong></p>
    <p>クイックソートのステップは、ピボットの選択戦略とパーティション戦略によって具体的な動作が変わるため、上記は一例です。重要なのは「分割して、それぞれを独立にソートし、最後に（暗黙的に）結合される」という分割統治の考え方です。</p>
</section>